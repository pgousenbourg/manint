function [Z, varargout] = blendedSurface(varargin);
% Returns the value Z of the blended surface at coordinate X,Y.
%    The blended surface fits a set of data points DATAPOINTS
%    at coordinates DATACOORDS with a fitting focus LAMBDA.
%
%    Z = blendedSurface(M,DATAPOINTS,DATACOORDS,X,Y) returns Z, the 
%    value at coordinate [X,Y] of the blended surface interpolating the 
%    DATAPOINTS on a manifold M, associated with coordinates DATACOORDS.
%    DATAPOINTS are stored in a vector-cell of N entries, and DATACOORDS
%    are stored in a [Nx2] vector, where each line corresponds to 
%    the coordinate of the associated datapoint.
% 
%    Z = blendedSurface(M,DATAPOINTS,[],X,Y) tries to interpolate the 
%    datapoints DATAPOINTS without the knowledge of the data coordinates.
%    In that case, the algorithm tries to associate data coordinates to 
%    the data points, on a regular grid. If not possible, an error is 
%    returned.
%
%    Z = blendedSurface(M,DATAPOINTS,DATACOORDS,X,Y,'lambda',LAMBDA)
%    fits the datapoints with a specific focus lambda (from 0 to NaN).
%    When lambda is NaN, interpolation is performed. If lambda is low,
%    then less importance is given to data points.
%
%    Z = blendedSurface(M,DATAPOINTS,DATACOORDS,X,Y,'options',OPTIONS)
%    permits to add some options to the system. The options are 
%    given hereunder.
%
%    [Z,elements] = blendedSurface(M,DATAPOINTS,DATACOORDS,X,Y), returns
%    also all the elements used in the blending procedure (dataPoints, 
%    dataCoords, options, lambda, etc.) in a structure ELEMENTS.
%
% Mandatory entries are:
%             M : The manifold on which the data points are 
%                 expressed.
%
%           X,Y : The grid of coordinates at which the surface
%                 is evaluated.
%
%    dataPoints : The data points to be fitted. Those points
%                 belong to M and are stored in a vector-cell
%                 of N entries.
%
%    dataCoords : Matrix [N x 2] of (x,y)-values, associated
%                 to each dataPoint.
%
% 
% Optional entries are:
%     lambda : the fitting parameter (scalar), from 0 to NaN, strictly
%              greater than zero. If not provided or NaN, then
%              interpolation is performed by default. 
%
%    options : a structure of option.
%
%
% The possible OPTIONS are the following:
%              rootPoints : The rootPoints in M, stored in a vector-cell
%                           of size P.
%
%              rootCoords : The coordinates at which the root points are
%                           lying. They are stored in a [P x 2] matrix,
%                           where each line corresponds to the (x,y)-
%                           coordinate of the corresponding rootPoint.
%
%                 domains : The domains generated by each rootCoord.
%                           By default, the domain is a rectilinear grid
%                           generated by the algorithm. If the domain 
%                           is refined, then they must be given as in 
%                           finite elements, i.e., in a 5xQ matrix,
%                           where each line specifies a domain, with
%                           columns 2 to 5 corresponding to the indexes
%                           of the rootCoords, ordered as 
%                                Y         3 -- 4
%                                ^         |    |
%                                |--> X    1 -- 2
%                           and where the first column is a parenting
%                           index relative to another line. If no idea,
%                           put ZERO.
%                           See also: makeDomain, refineDomain, plotDomain
%
%        generationMethod : method that generates the minimal 
%                           representation of the fitting surface on the 
%                           tangent space. Given as a STRING value.
%                           Possible values are: 
%                              'TPS'    - thin plate splines (default)
%                              'Bezier' - bezier surfaces
%
%    reconstructionMethod : method that reconstruct the fitting surface
%                           based on its minimal representation.
%                           Possible values are:
%                              'TPS'    - thin plate splines (default)
%                              'Bezier' - bezier surfaces
%                           /!\ TPS generation does not work with Bezier
%                               reconstruction, and vice-versa.
%
%           liftingMethod : method that lifts the data points from M to 
%                           a tangent space at a rootPoint.
%                           Possible values are:
%                              'basic'     - default
%                              'transport' - transports local information
%                              'coarse'    - summarizes local information
%
%         blendingWeights : handle function that computes weights at
%                           a given X,Y value, for blending.
%                           Format is (X,Y) = @f(X,Y). Output must be
%                           a [4-vector] corresponding to the weight 
%                           associated to each surface to blend
%                           (see the help of blendSurfWeights for more
%                           info).
%                           By default: @blendSurfWeights
%
%          blendingMethod : method for blending.
%                           Possible values are
%                              'tensor'  - fast method (default) using
%                                          @tensorMean
%                              'karcher' - accurate (but slow) method 
%                                          using @karcherMean
%
%                 display : boolean value. 1 for displaying stuff, 
%                           0 for shutting it down.
%                           By default: 0 (no display)
%
%                 verbose : Level of verbosity (0 for no verbose, 1 for
%                           normal verbosity or 2 for full verbosity).
%                           By default: 1 (normal verbose)
%                           /!\ Not Yet In Production /!\
%
%
% Advanced functionality of OPTIONS:
% Some options are handle functions that can be overrided by the user.
% We STRONGLY DISCOURAGE this practice, but here are the description of
% the methods:
%                 lifting : handle function that lifts the data points
%                           from M to a tangent space at a rootPoint.
%                           Minimal inputs must be:
%                             - the dataPoints in a N-cell;
%                             - the rootPoint at which the dataPoints
%                               must be lifted;
%                             - the manifold M.
%                           Minimal output must be a N-cell with the
%                           lifted points.
%                           See the documentation of basicLifting for
%                           a structural description.
%                           By default: @basicLifting
%
%                blending : handle function for blending.
%                           Minimal inputs are:
%                             - four points in a N-cell;
%                             - four weights in a 4-vector.
%                           See the documentation of tensorMean for a 
%                           structural description. 
%                           By default: @tensorMean
%
% Original author: 
% 	Pierre-Yves Gousenbourger, Dec. 19, 2019.
% Contributors: 
%
% Change log:
% 	Dec. 19, 2019 (PYG) - First version.
% 	Mar. 24, 2020 (PYG) - Logic and help.

% Manint - Copyright (C) <2014-2020> <UniversitÃ© catholique de Louvain (UCL), Belgique>
%	
% List of the contributors to the development of Manint: see AUTHORS file.
% Description and complete License: see LICENSE file.
%
% This program (Manint) is free software: 
% you can redistribute it and/or modify it under the terms of the 
% GNU General Public License as published by the Free Software Foundation, 
% either version 3 of the License, or (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program (see COPYING file).  If not, 
% see <http://www.gnu.org/licenses/>.

  % ====================================================================
  % input management
  % ====================================================================
  
  % create the parser
  ip = inputParser();
  % required inputs
  addRequired(ip,'M')
  addRequired(ip,'dataPoints')
  addRequired(ip,'dataCoords');
  addRequired(ip,'X')
  addRequired(ip,'Y')
  
  % optional inputs
  addOptional(ip,'lambda',NaN); % interpolation by default
  addOptional(ip,'options',[]); % default options

  % parse the parser as a structure.
  parse(ip, varargin{:});
  vars = ip.Results;
  
  % Checks inputs, fills empty entries, verifies the coherence of inputs
  checkInputs(vars);
  vars = fillInputs(vars);
  coherenceOfInputs(vars);
  
  
  % ====================================================================
  % Prepare the parameters
  % ====================================================================
  M          = vars.M;
  dataPoints = vars.dataPoints;
  dataCoords = vars.dataCoords;
  dimX       = size(vars.X);
  dimM       = size(dataPoints{1});
  X          = vars.X(:);
  Y          = vars.Y(:);
  lambda     = vars.lambda;
  rootPoints = vars.options.rootPoints;
  rootCoords = vars.options.rootCoords;
  domains    = simplifyDomain(vars.options.domains); % simplified domain
  blendingWeights = vars.options.blendingWeights;
  tangentSurfaces = cell(size(rootPoints));
  
  % useful variables
  nTimes   = length(X);
  nData    = length(dataPoints);
  nRoots   = length(rootPoints);
  nDomains = size(domains,1);
  
  
  % ====================================================================
  % Generate the methods
  % ====================================================================
  switch vars.options.generationMethod
    case 'TPS';    generation = @(dp,dc) thinPlateSplineGeneration(dp,dc,lambda);
    case 'bezier'
      bezierOptions.patchM = length(unique(rootCoords(:,1)))-1; 
      bezierOptions.patchN = length(unique(rootCoords(:,2)))-1;
      if lambda == 0;
        bezierLambda = 1e8;
      else
        bezierLambda = 1/lambda;
      end
      generation = @(dp,dc) bezierSurfaceSplineGeneration(dp,dc,bezierLambda,'rootCoords',rootCoords,'options',bezierOptions);
      %generation = @(dp,dc) bezierSurfaceSplineGeneration(dp,dc,bezierLambda);
    otherwise; error('Wrong generation method label provided');
  end
  switch vars.options.reconstructionMethod
    case 'TPS';    reconstruction = @(x,y,ad) thinPlateSplineReconstruction(x,y,ad,dataCoords);
    case 'bezier'; reconstruction = @(x,y,b) bezierSurfaceSplineReconstruction(x,y,b,rootCoords);
    otherwise; error('Wrong reconstruction method label provided');
  end
  if ~isfield(vars.options,'lifting')
    switch vars.options.liftingMethod
    case 'basic';     lifting = @(man,root,dp) basicLifting(man,root,dp);
    case 'transport'; lifting = @(man,root,dp) transportLifting(man,root,dp,domains,rootCoords,dataCoords);
    case 'coarse' ;   error('Coarse lifting is not integrated yet...'); %lifting = @(man,root,dp) coarseLifting(man,root,dp);
    otherwise; error('Wrong lifting method label provided');
    end
  end
  if ~isfield(vars.options,'blending')
    switch vars.options.blendingMethod
    case 'tensor';  blending = @(man,pts,w) tensorMean(man,pts,w); 
    case 'karcher'; blending = @(man,pts,w) karcherMean(man,pts,w);
    otherwise; error('Wrong blending method label provided');
    end
  end
  
  
  % ====================================================================
  % The algorithm can finally start here
  % ====================================================================
  
  % lift the data points to corners of the domain
  tangentPoints = lifting(M,rootPoints,dataPoints);
  
  % generate the minimal curve representation on each root
  for i = 1:nRoots
    tangentSurfaces{i} = generation(tangentPoints(i,:),dataCoords);
  end
  
  % Blend the solutions together
  Z = zeros([length(X),dimM]);
  % Find in which domain each (X,Y) belongs
  XYdomain = findDomain(X,Y,domains,rootCoords); 
  for i = 1:nDomains
    % Find the (X,Y) of the ith domain
    XYIdx = find(XYdomain == i);
    
    if ~isempty(XYIdx)
      % Roots and surface representation of the patch
      Xtemp = X(XYIdx);
      Ytemp = Y(XYIdx);
      rootsIdx = domains(i,2:5);
      roots    = rootPoints(rootsIdx)';
      rootsC   = rootCoords(rootsIdx,:);
      surfaces = tangentSurfaces(rootsIdx)';
      
      % Compute the four tangent surfaces at those (X,Y) pairs
      tangentValues = cell(4,1);
      for j = 1:4
        tangentValues{j} = reconstruction(Xtemp,Ytemp,surfaces{j});
      end
      
      % Compute the blendedSurface for those (X,Y) pairs
      weights  = blendingWeights(Xtemp,Ytemp,rootsC);
      
      % Store in blendedSurf    
      Z(XYIdx,:,:) = blendSurfaces(M,roots,tangentValues,weights,blending);
    end
  end

  % return values
  Z = squeeze(reshape(Z,[dimX dimM]));
  
  if nargout > 1
    elements = vars;
    elements.options.reconstruction = reconstruction;
    elements.options.generation = generation;
    elements.options.lifting = lifting;
    elements.options.blending = blending;
    elements.options = orderfields(elements.options);
    elements.tangentSurfaces = tangentSurfaces;
    varargout{1} = elements;
  end
end
